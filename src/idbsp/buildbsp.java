package idbsp;

import static idbsp.doombsp.ML_TWOSIDED;
import static idbsp.doomload.linestore_i;

import java.util.ArrayList;
import java.util.List;

import idbsp.doombsp.NXPoint;
import idbsp.doombsp.bspnode_t;
import idbsp.doombsp.divline_t;
import idbsp.doombsp.line_t;
import idbsp.doombsp.worldline_t;
import static idbsp.drawing.UpdateDrawing;
import static idbsp.cmdlib.Error;


/**
 * doombsp.c / doombsp.h
 * 
 * @author
 *
 */

public class buildbsp {

	public static int			cuts;			// number of new lines generated by BSP process
	public static bspnode_t	startnode;

	public static List<line_t> 	segstore_i = new ArrayList<>();
	public static List<line_t> 	bestlines_i = new ArrayList<>();

	
	/*
	==================
	=
	= PointOnSide
	=
	= Returns side 0 (front), 1 (back), or -1 (collinear)
	==================
	*/

	public static int	PointOnSide (NXPoint p, divline_t l) {
		double	dx, dy;
		double 	left, right;
		double	a, b, c, d;
		
		if (l.dx == 0) {
			if (p.x > l.pt.x - 2 && p.x < l.pt.x + 2) {
				return -1;
			}
			if (p.x < l.pt.x) {
				return (l.dy > 0 ? 1 : 0);
			}
			return (l.dy < 0 ? 1 : 0);
		}
		
		if (l.dy == 0) {
			if (p.y > l.pt.y - 2 && p.y < l.pt.y + 2) {
				return -1;
			}
			if (p.y < l.pt.y) {
				return (l.dx < 0 ? 1 : 0);
			}
			return (l.dx > 0 ? 1 : 0);
		}

		// Quadratische Gleichung
		// Ansatz:
		// Sei r = (l.dx, l.dy) der Richtungsvektor der divline
		// Frage: Ist dann dist( p,  (l.pt + t * r) ) < 2 für ein t?
		// (p.x - l.pt.x - t * l.dx) ^ 2 + (p.y - l.pt.y - t * l.dy) ^ 2 < 4 ?
		// (dx + t*l.dx)^2 + (dy + t*l.dy)^2 - 4 < 0 ?
		// dx^2 + t*2*dx*l.dx + t^2*l.dx^2 + dy^2 + t*2*dy*l.dy + t^2*l.dy^2 - 4 < 0?
		// a = l.dx * l.dx + l.dy * l.dy
		// b = 2 * (l.dx * dx + l.dy * dy)
		// c = dx * dx + dy * dy - 4
		// a * t^2 + b * t + c < 0 ?
		// Frage: Ist b * b - 4 * a * c > 0 ?
		
		dx = l.pt.x - p.x;
		dy = l.pt.y - p.y;
		a = l.dx * l.dx + l.dy * l.dy;
		b = 2 * (l.dx * dx + l.dy * dy);
		c = dx * dx + dy * dy - 2 * 2;		// 2 unit radius
		d = b * b - 4 * a * c;
		if (d > 0) {
			return -1;						// within four pixels of line
		}
		
		// Kreuzprodukt
		//  dx     l.dx        0
		//  dy  x  l.dy   =    0
		//  0      0           dx * l.dy - dy * l.dx
		
		dx = p.x - l.pt.x;
		dy = p.y - l.pt.y;
		
		left = l.dy * dx;
		right = dy * l.dx;
		
		if (Math.abs(left - right) < 0.5) {
			// allow slop on line
			return -1;		
		}
		if (right < left) {
			return 0;		// front side
		}
		return 1;			// back side
	}
	
	
	// Alternativ:
	// Bilde Normalform divline_t als Lösung von a * x + b * y + c = 0 ab:
	// a = l.dy
	// b = - l.dx
	// c = - l.dy * l.pt.x + l.dx * l.pt.y
	// Damit Normalform: (l.dy * x - l.dx * y - l.dy * l.pt.x + l.dx * l.pt.y) / sqrt( l.dx * l.dx + l.dy * l.dy)
	//                 = l.dx * (l.pt.y - y) - l.dy * (l.pt.x - x) / sqrt(...)
	// Einsetzen eines Wertes (x,y) liefert Abstand von der Geraden; Vorzeichen: positiv = vorn, negativ = hinten
	
	public static int	PointOnSide4 (NXPoint p, divline_t l) {
		if (l.dx == 0) {
			if (p.x > l.pt.x - 2 && p.x < l.pt.x + 2) {
				return -1;
			}
			if (p.x < l.pt.x) {
				return (l.dy > 0 ? 1 : 0);
			}
			return (l.dy < 0 ? 1 : 0);
		}
		
		if (l.dy == 0) {
			if (p.y > l.pt.y - 2 && p.y < l.pt.y + 2) {
				return -1;
			}
			if (p.y < l.pt.y) {
				return (l.dx < 0 ? 1 : 0);
			}
			return (l.dx > 0 ? 1 : 0);
		}

		double e = l.dx * (l.pt.y - p.y) - l.dy * (l.pt.x - p.x);
		double f = l.dx * l.dx + l.dy * l.dy;
		return (e * e < 4 * f ? -1 : (e > 0 ? 0 : 1));
	}	
	

	/*
	==================
	=
	= DivlineFromWorldline
	=
	==================
	*/

	private static void	DivlineFromWorldline (divline_t d, line_t w) {
		d.pt = w.p1;
		d.dx = w.p2.x - w.p1.x;
		d.dy = w.p2.y - w.p1.y;
	}


	
	/*
	=====================
	=
	= BuildBSP
	=
	=====================
	*/

	public static void BuildBSP () {
		MakeSegs ();
		cuts = 0;
		startnode = BSPList (segstore_i);
		
//		System.out.println(cuts + " cuts");
//		
//		UpdateDrawing();

	}

	/*
	================
	=
	= BSPList
	=
	= Takes a storage of lines and recursively partitions the list
	= Returns a bspnode_t
	================
	*/

	private static bspnode_t BSPList (List<line_t> lines_i) {
		
		bspnode_t node_p = new bspnode_t();
		node_p.divline = new divline_t();
		
		//
		// find the best line to partition on 
		//
		int c = lines_i.size();
		int bestv = Integer.MAX_VALUE;	
		line_t bestline_p = null;
		int step = 1; // (c / 40) + 1;		// set this to 1 for an exhaustive search
		while (bestv == Integer.MAX_VALUE) {
			for (int i = 0 ; i < c ; i += step) {
				line_t line_p = lines_i.get(i);
				int v = EvaluateSplit (lines_i, line_p, bestv);
				if (v < bestv) {
					bestv = v;
					bestline_p = line_p;
				}
			}
			
			if (bestv == Integer.MAX_VALUE) {
				if (step > 1) {	// possible to get here with non convex area if BSPSLIDE specials caused rejections
					step = 1;
					continue;
				}
				node_p.lines_i = lines_i;
//				System.out.println("LEAVE: " + lines_i.size());
				return node_p;
			}
		}		
		
		System.out.println("BEST: " + bestv + "/" + c);
		//
		// if none of the lines should be split, the remaining lines
		// are convex, and form a terminal node
		//

		//
		// divide the line list into two nodes along the best split line
		//
		DivlineFromWorldline (node_p.divline, bestline_p);

		List<line_t> frontlist_i = new ArrayList<>();
		List<line_t> backlist_i = new ArrayList<>();
		
		ExecuteSplit (lines_i, bestline_p, frontlist_i, backlist_i);

		bestlines_i = frontlist_i;
		UpdateDrawing();
		
//		try {
//			Thread.sleep(1000);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
		
		bestlines_i = backlist_i;
		UpdateDrawing();
		
//		try {
//			Thread.sleep(1000);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
		
		//
		// recursively divide the lists
		//
		node_p.side = new bspnode_t[2];
		node_p.side[0] = BSPList (frontlist_i);
		node_p.side[1] = BSPList (backlist_i);
			
		return node_p;
	}
	
	/*
	=====================
	=
	= MakeSegs
	=
	=====================
	*/

	private static void MakeSegs () {
		line_t li;
		for (int i = 0; i < linestore_i.size(); i++) {
			worldline_t wl = linestore_i.get(i);
			
			li = new line_t();
			li.p1 = wl.p1;
			li.p2 = wl.p2;
			li.linedef = i;
			li.side = 0;
			li.offset = 0;
			li.grouped = false;
			
			segstore_i.add(li);
			
			if ((wl.flags & ML_TWOSIDED) != 0) {
				li = new line_t();
				li.p1 = wl.p2;
				li.p2 = wl.p1;
				li.linedef = i;
				li.side = 1;
				li.offset = 0;
				li.grouped = false;
				
				segstore_i.add(li);
			}
		}
	}


	/*
	================
	=
	= EvaluateSplit
	=
	= Returns a number grading the quality of a split along the given line
	= for the current list of lines.  Evaluation is halted as soon as it is
	= determined that a better split already exists
	= 
	= A split is good if it divides the lines evenly without cutting many lines
	= A horizontal or vertical split is better than a sloping split
	=
	= The LOWER the returned value, the better.  If the split line does not divide
	= any of the lines at all, MAXINT will be returned
	================
	*/

	private static int EvaluateSplit (List<line_t> lines_i, line_t spliton, int bestgrade) {
		int				i, c, side;
		line_t			line_p;
		divline_t		divline = new divline_t();
		int				frontcount, backcount, maxl, newl;
		int				grade = 0;
		worldline_t		wl;
		
		wl = linestore_i.get(spliton.linedef);
		DivlineFromWorldline (divline, spliton);
		
		frontcount = backcount = 0;
		c = lines_i.size();
		grade = 0;
			
		for (i = 0 ; i < c ; i++) {
			line_p =  lines_i.get(i);
			if (line_p == spliton) {
				side = 0;
			} else {
				side = LineOnSide (line_p, divline);
			}
			switch (side) {
			case 0:
				frontcount++;
				break;
			case 1:
				backcount++;
				break;
			case -2:
				wl = linestore_i.get(line_p.linedef);
				frontcount++;
				backcount++;
				break;
			}
			
			maxl = Math.max(frontcount, backcount);
			newl = (frontcount + backcount) - c;
			grade = maxl + newl * 8;
			if (grade > bestgrade)
				return grade;		// might as well stop now
		}
		
		if (frontcount == 0 || backcount == 0)
			return Integer.MAX_VALUE;			// line does not partition at all
			
		return grade;
	}


	/*
	==================
	=
	= LineOnSide
	=
	= Returns side 0 / 1, or -2 if line must be split
	= If the line is colinear, it will be placed on the front side if
	= it is going the same direction as the dividing line
	==================
	*/

	private static int	LineOnSide (line_t wl, divline_t bl) {
		int		s1,s2;
		double	dx, dy;
		
		s1 = PointOnSide (wl.p1, bl);
		s2 = PointOnSide (wl.p2, bl);

		if (s1 == s2) {
			if (s1 == -1) {
				// colinear, so see if the directions are the same
				dx = wl.p2.x - wl.p1.x;
				dy = wl.p2.y - wl.p1.y;
				if (Math.signum(dx) == Math.signum(bl.dx) && Math.signum(dy) == Math.signum(bl.dy)) {
					return 0;
				}
				return 1;
			}
			return s1;
		}
		if (s1 == -1) {
			return s2;
		}
		if (s2 == -1) {
			return s1;
		}
			
		return -2;
	}

	/*
	================
	=
	= ExecuteSplit
	=
	= Actually splits the line list as EvaluateLines predicted
	================
	*/

	private static void ExecuteSplit (List<line_t> lines_i, line_t spliton, List<line_t> frontlist_i, List<line_t> backlist_i) {
		int				i, c, side;
		line_t			line_p, newline_p;
		divline_t		divline = new divline_t();
		
		DivlineFromWorldline (divline, spliton);

		c = lines_i.size();
			
		for (i = 0 ; i < c ; i++) {
			line_p = lines_i.get(i);
			if (line_p == spliton) {
				side = 0;
			} else {
				side = LineOnSide (line_p, divline);
			}
			switch (side) {
			case 0:
				frontlist_i.add(line_p);
				break;
			case 1:
				backlist_i.add(line_p);
				break;
			case -2:
				newline_p = CutLine (line_p, divline);
				frontlist_i.add(line_p);
				backlist_i.add(newline_p);
				break;
			default:
				Error ("ExecuteSplit: bad side");
			}
		}
	}

	/*
	==================
	=
	= CutLine
	=
	= Truncates the given worldline to the front side of the divline
	= and returns the cut off back side in a newly allocated worldline
	==================
	*/

	private static double round (double x) {
		if (x > 0) {
			if (x - (int) x < 0.1) {
				return (int) x;
			} else if (x - (int) x > 0.9) {
				return (int) x + 1;
			} else {
				return x;
			}
		}
		
		if ((int) x - x < 0.1) {
			return (int) x;
		} else if ((int) x - x > 0.9) {
			return  (int) x - 1;
		}
		return x;
	}

	private static line_t	CutLine (line_t wl, divline_t bl) {
		int			side;
		line_t		new_p = new line_t();
		divline_t	wld = new divline_t();
		double		frac;
		NXPoint		intr = new NXPoint();
		int			offset;
		
		cuts++;
		DivlineFromWorldline (wld, wl);
		
		new_p.p1 = wl.p1; 
		new_p.p2 = wl.p2; 
		new_p.linedef = wl.linedef; 
		new_p.side = wl.side; 
		new_p.offset = wl.offset; 
		new_p.grouped = wl.grouped; 
		
		frac = InterceptVector (wld, bl);
		intr.x = wld.pt.x + round(wld.dx * frac);
		intr.y = wld.pt.y + round(wld.dy * frac);
		
		offset = (int) (wl.offset + round(frac * Math.sqrt(wld.dx * wld.dx + wld.dy * wld.dy)));
		side = PointOnSide (wl.p1, bl);
		if (side == 0) {
			// line starts on front side
			wl.p2 = intr;
			new_p.p1 = intr;
			new_p.offset = offset;
		} else {	
			// line starts on back side
			wl.p1 = intr;
			wl.offset = offset;
			new_p.p2 = intr;
		}
		
		return new_p;
	}

	/*
	===============
	=
	= InterceptVector
	=
	= Returns the fractional intercept point along first vector
	===============
	*/

	private static double InterceptVector (divline_t v2, divline_t v1) {
		double	frac, num, den;
		
		den = v1.dy * v2.dx - v1.dx * v2.dy;
		if (den == 0) {
			Error ("InterceptVector: parallel");
		}
		num = (v1.pt.x - v2.pt.x) * v1.dy + (v2.pt.y - v1.pt.y) * v1.dx;
		frac = num / den;

		if (frac <= 0.0 || frac >= 1.0)
			Error ("InterceptVector: intersection outside line");
			
		return frac;
	}


	
}
